// backend/routes/communeRoutes.js
const express = require('express');
const router = express.Router();
const mongoose = require('mongoose');
const Commune = require('../models/Commune');
const User = require('../models/User'); // ⬅️ nécessaire pour mettre à jour les admins liés
const auth = require('../middleware/authMiddleware');
const requireRole = require('../middleware/requireRole');

// utils
const escapeRegExp = (s) => String(s || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
const stripAccents = (s = '') =>
  String(s).normalize('NFD').replace(/[\u0300-\u036f]/g, '');
const slugify = (s = '') =>
  stripAccents(String(s))
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .replace(/--+/g, '-');

const isValidHex24 = (s) => typeof s === 'string' && /^[a-f0-9]{24}$/i.test(s);
const norm = (v) => String(v || '').trim().toLowerCase();

/** Recherche robuste d'une commune par id/slug/code/nom */
async function findCommuneByAny(any) {
  const raw = String(any || '').trim();
  if (!raw) return null;

  // 1) ObjectId
  if (isValidHex24(raw)) {
    const byId = await Commune.findById(raw).lean();
    if (byId) return byId;
  }

  // 2) slug (case-insensitive)
  let c = await Commune.findOne({ slug: new RegExp(`^${escapeRegExp(raw)}$`, 'i') }).lean();
  if (c) return c;

  // 3) autres champs uniques éventuels
  c = await Commune.findOne({ code: new RegExp(`^${escapeRegExp(raw)}$`, 'i') }).lean();
  if (c) return c;

  // 4) noms
  const nameFields = ['name', 'label', 'communeName', 'region'];
  for (const f of nameFields) {
    c = await Commune.findOne({ [f]: new RegExp(`^${escapeRegExp(raw)}$`, 'i') }).lean();
    if (c) return c;
  }

  return null;
}

/**
 * IMPORTANT
 *  - On NE met PAS "/api" dans les chemins ci-dessous.
 *  - Le préfixe "/api" est ajouté dans server.js via app.use('/api/communes', router)
 *  - Donc:
 *      GET    /api/communes           -> liste publique (app mobile)
 *      GET    /api/communes/admin     -> liste complète (panel superadmin)
 *      POST   /api/communes           -> créer une commune (superadmin)
 *      DELETE /api/communes/:id       -> supprimer une commune (superadmin)
 */

// ========== PUBLIC: liste des communes (utilisé par l’app mobile) ==========
router.get('/', async (req, res) => {
  try {
    const { q = '' } = req.query;

    // publiques: actives (ou sans champ active)
    const find = { $or: [{ active: { $exists: false } }, { active: { $ne: false } }] };

    if (q) {
      const rx = new RegExp(escapeRegExp(String(q)), 'i');
      find.$or = [
        ...find.$or,
        { name: rx },
        { label: rx },
        { communeName: rx },
        { slug: rx },
        { code: rx },
        { region: rx },
      ];
    }

    const items = await Commune.find(find)
      .select({
        name: 1,
        label: 1,
        communeName: 1,
        code: 1,
        region: 1,
        imageUrl: 1,
        slug: 1,
        active: 1,
      })
      .sort({ name: 1 })
      .lean();

    res.setHeader('Cache-Control', 'no-store, max-age=0');
    return res.json(items);
  } catch (e) {
    console.error('❌ GET /communes', e);
    return res.status(500).json({ message: 'Erreur serveur' });
  }
});

// ========== ADMIN (superadmin): liste complète (panel) ==========
router.get('/admin', auth, requireRole('superadmin'), async (req, res) => {
  try {
    const items = await Commune.find().sort({ name: 1 }).lean();
    res.setHeader('Cache-Control', 'no-store');
    return res.json({ items, total: items.length });
  } catch (e) {
    console.error('❌ GET /communes/admin', e);
    return res.status(500).json({ message: 'Erreur serveur' });
  }
});

// ========== ADMIN (superadmin): création d’une commune ==========
router.post('/', auth, requireRole('superadmin'), async (req, res) => {
  try {
    const {
      name = '',
      slug = '',
      code = '',
      region = '',
      imageUrl = '',
      active = true,
    } = req.body || {};

    const base = (slug || name || '').trim();
    if (!base) return res.status(400).json({ message: 'Nom ou slug requis' });

    const baseSlug = slugify(base) || `commune-${Date.now()}`;
    let finalSlug = baseSlug;
    let i = 1;

    // éviter les doublons de slug
    while (await Commune.findOne({ slug: finalSlug }).lean()) {
      i += 1;
      finalSlug = `${baseSlug}-${i}`;
    }

    const payload = {
      name: name || base,
      label: name || base,
      communeName: name || base,
      code,
      region,
      imageUrl,
      slug: finalSlug,
      active: !!active,
    };

    const doc = await Commune.create(payload);

    res.setHeader('Cache-Control', 'no-store');
    return res.status(201).json(doc);
  } catch (e) {
    console.error('❌ POST /communes', e);
    return res.status(500).json({ message: 'Erreur serveur' });
  }
});

// ========== ADMIN (superadmin): suppression d’une commune ==========
router.delete('/:id', auth, requireRole('superadmin'), async (req, res) => {
  try {
    const any = req.params.id || req.query.id || (req.body && req.body.id) || '';
    const doc = await findCommuneByAny(any);

    if (!doc) return res.status(404).json({ message: 'Commune introuvable' });

    const slugKey = norm(doc.slug || doc._id);

    // (optionnel mais conseillé) Met à jour les comptes admin rattachés :
    // - on désactive le compte
    // - on nettoie la commune pour éviter les incohérences côté panel
    await User.updateMany(
      { role: 'admin', communeId: slugKey },
      { $set: { isActive: false, communeId: '', communeName: '' } }
    );

    await Commune.deleteOne({ _id: doc._id });

    res.setHeader('Cache-Control', 'no-store');
    // 204 = pas de body ; 200 avec JSON si tu veux un message
    return res.status(200).json({ ok: true, deleted: slugKey });
  } catch (e) {
    console.error('❌ DELETE /communes/:id', e);
    return res.status(500).json({ message: 'Erreur serveur' });
  }
});

module.exports = router;
